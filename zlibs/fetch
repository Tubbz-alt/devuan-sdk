#!/usr/bin/env zsh

# web client command
webc="elinks -no-numbering -dump -dump-width 256"


import() {
    [[ "$cmd_name" = "" ]] && {
        print "no package name set?!"
        return 1
    }

    mkdir -p sources

    pkg_url=https://packages.debian.org/${release}/${cmd_name}
    web_info=`${=webc} ${pkg_url}`
    # fetch sources
    typeset -aU pkg_sources
    pkg_sources=(`print $web_info | awk '

BEGIN { found=0 }

/Download Source Package/ { found=1; next }

/Maintainer/ { exit }

{ if(found==1) {
      src=sub(/.*\*.*\[/, "", $0)
      src=sub(/\]$/, "", $src)
      print $src
  }
}

'`)
    pkg_name=${pkg_sources[1]}
    pkg_name=${pkg_name[(ws:_:)1]}
    print
    print "Source package name: $pkg_name"
    print
    # get first package letter
    alpha=${pkg_name[1]}

    # render url
    source_url=${mirror}/pool/${section}/${alpha}/${pkg_name}
    
    pkg_dsc_file=""
    pkg_debian_file=""
    pkg_orig_file=""
    # fetch sources
    for s in $pkg_sources; do
        print "Source file: $s"
        [[ -r sources/${s} ]] || {
            curl "${source_url}/$s" -o sources/$s
            [[ $? = 0 ]] || {
                print "Error downloading: $s"
                print "Url: ${source_url}/$s"
                return 1
            }
        }
        if [[ "$s" -regex-match ".*\.dsc$" ]]; then
            pkg_dsc_file=$s 
        elif [[ "$s" -regex-match ".*\.debian\..*" ]]; then
            pkg_debian_file=$s
        else
            pkg_orig_file=$s
        fi
    done    

    # calculate version from package filename
    pkg_ver=${pkg_dsc_file[(ws:_:)2]}
    pkg_ver=${pkg_ver[(ws:-:)1]}
    pkg_ver=${pkg_ver%*.dsc}

    # calculate destination directory from tar contents
    t=`tarcmd ${pkg_orig_file}`
    pkg_dest_dir=`tar tvf$t sources/$pkg_orig_file | awk '
{ print $6; exit }
'`
    pkg_dest_dir=${pkg_dest_dir%*/}

    print "Package version: $pkg_ver"
    print "Package destination: $pkg_dest_dir"
    print "Package description: $pkg_dsc_file"
    print "Package orig source: $pkg_orig_file"
    [[ "$pkg_debian_file" = "" ]] || \
        print "Package deb  source: $pkg_debian_file"
    # update the prompt
    rprompt
}

gpg_fast="gpg2 --no-default-keyring --no-auto-check-trustdb --keyring $sdk_path/.gnupg/pubring.gpg --batch"
gpg="gpg2 --no-default-keyring --keyring $sdk_path/.gnupg/pubring.gpg --batch"


verify() {

    import

    pkg_dsc=`cat sources/${pkg_dsc_file}`

    hash_map=()
    hash_dsc_256=`print - $pkg_dsc | awk '
BEGIN { found=0 }
/^Checksums-Sha256:/ { found=1; next }
/'"$pkg_name"'/ { if(found==1) print "hash_map+=(" $3 " " $1")"; next }
{ if(found==1) exit }
'`
    eval $hash_dsc_256 # fills hash_map

    for f in ${(k)hash_map}; do
        print
        print "SHA256 desc checksum: ${hash_map[$f]} ${f}"
        hash_tar_256=`sha256sum sources/$f | awk '{print $1}'`
        print "SHA256 file checksum: $hash_tar_256 ${f}"
        print
    done
    print - $pkg_dsc | ${=gpg} --verify
    return $?
}

unpack() {

    verify

    print
    print "Decompressing orig source file"
    t=`tarcmd ${pkg_orig_file}`
    tar xf$t sources/${pkg_orig_file} -C sources
    [[ -d sources/${pkg_dest_dir} ]] || {
        print "Error guessing package destination, not found: sources/${pkg_dest_dir}"
        return 1
    }
    [[ "$pkg_debian_file" = "" ]] || {
        print "Decompressing debian source file"
        tar xfJ sources/${pkg_debian_file} -C sources/${pkg_dest_dir}/
        [[ $? = 0 ]] || return 1
    }

    print
    return $?
}

# wrapper to include local gitconfig    
    

stage() {

    unpack   

    mkdir -p stage
    [[ -d $sdk_path/stage/$pkg_name ]] && {
        staged_pkg_ver="no stamp"
        [[ -r $sdk_path/stage/$pkg_name/.devuan ]] && {
            staged_pkg_ver=`awk '/source_ver/ {print $2}' $sdk_path/stage/$pkg_name/.devuan`
        }
        print "Already staged: $pkg_name ($staged_pkg_ver)"
        print "Remote: https://git.devuan.org/packages-base/${pkg_name}"

        [[ "$staged_pkg_ver" = "$pkg_ver" ]] || {
            print "Creating branch for version: $pkg_ver"
            pushd $sdk_path/stage/$pkg_name
            git checkout -b v${pkg_ver}
            rsync -raX $sdk_path/sources/$pkg_dest_dir/* \
                $sdk_path/stage/$pkg_name/
            git add .
            git commit -m "branched new version $pkg_ver"
            popd

            stamp
        }
        return 0
    }
    mkdir -p $sdk_path/stage/$pkg_name
    rsync -raX $sdk_path/sources/$pkg_dest_dir/* \
        $sdk_path/stage/$pkg_name/
    pushd $sdk_path/stage/$pkg_name
    git init
    git add .
    git commit -m "Import from Debian $release/$section package $pkg_name-$pkg_ver"
    git remote add origin git@git.devuan.org:packages-base/${pkg_name}
    popd
    print "Stage successfull: stage/$pkg_name"
    print "Remote: https://git.devuan.org/packages-base/${pkg_name}"
    print

    stamp

    return 0

}

stamp() {

    [[ -d $sdk_path/stage/$pkg_name ]] || {
        print "Cannot stamp project, not staged yet"
        return 1
    }

    dst=$sdk_path/stage/$pkg_name/.devuan

    cat <<EOF > $dst
package_name: $cmd_name
source_name: $pkg_name
source_ver: $pkg_ver
source_dir: $pkg_dest_dir
source_dsc: $pkg_dsc_file
source_orig: $pkg_orig_file
source_debian: $pkg_debian_file
source_url: $source_url
begin: hash sha256
EOF
    for k in ${(k)hash_map}; do
        print "${hash_map[$k]} $k" >> $dst
    done
    cat <<EOF >> $dst
end: hash sha256
EOF
    pushd $sdk_path/stage/$pkg_name
    git add .devuan
    git commit -m "import stamp version $pkg_ver"    
    popd
}

init-repos() {
    url="https://git.devuan.org/groups"
    git="git@git.devuan.org:packages-base"
    print "Updating list of Devuan packages"
    repos=`curl -s https://git.devuan.org/groups/packages-base | awk '/a class=.*project/ { print $3}' | cut -d'"' -f2`
    pushd $sdk_path/stage
    for i in ${(f)repos}; do
        base=`basename $i`
        [[ -d $base ]] || {
            git clone ${git}/${base}.git
        }
    done
    popd
}

init-keyring() {
    [[ -r $sdk_path/.gnupg/pubring.gpg ]] && {
        print "Public keyring found."
        return 0
    }

    _cmd_name=$cmd_name

    cmd_name=debian-keyring
    
    unpack

    mkdir -p $sdk_path/.gnupg


    keys=`find sources/debian-keyring-${pkg_ver}/debian-maintainers-gpg -type f`
    for i in ${(f)keys}; do
        cat $i | ${=gpg_fast} --import
    done

    keys=`find sources/debian-keyring-${pkg_ver}/debian-keyring-gpg -type f`
    for i in ${(f)keys}; do
        cat $i | ${=gpg_fast} --import
    done

    print "GnuPG debian maintainers keyring succesfully imported"
    pkg_name=$_pkg_name
    pkg_ver=$_pkg_ver
    rprompt
}


# Old and deprecated
version-latest() {
    # scrape web search for latest package version
    # may need tweaking as we go by
    print "Querying: https://packages.debian.org/search?keywords=${pkg_name}&searchon=names&suite=${release}&section=${section}"
    ${=webc} "https://packages.debian.org/search?keywords=${pkg_name}&searchon=names&suite=${release}&section=${section}" | awk '

BEGIN { found=0 }

/Package '"$pkg_name"'/ { found=1 }

{ if(found>0) found++
  if(found==5) print $0 }

' | trim | sysread pkg_latest_ver
    # split to *: 
    pkg_latest_ver=${pkg_latest_ver[(ws@:@)1]}

    print "$pkg_name latest version is ${pkg_latest_ver}"

    version $pkg_latest_ver
}
